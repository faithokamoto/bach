#!/usr/bin/env python3
"""Find segments where mates map in an allele-biased way.
See --help for documentation.

For each SNP (assumed to be biallelic) in a VCF,
for sample BAM files (assumed to be position-sorted/indexed) in a directory,
split mates by their SNP allele, and find segments with allele bias.

Scan SNP chromosome with 15Mbp windows (5Mbp steps),
counts ref/alt mates for all samples, finds consistent bias.
Adjacent windows merged.

Heavily based on a script written by ChatGPT.
"""

import argparse  # Command-line argument parsing
import csv  # CSV output
import os  # File operations
import pysam  # Reading BAMs and VCF
from scipy.stats import binomtest

from typing import Dict, List, Tuple

SAMPLE_BAMS = Dict[str, str]
"""Dictionary of {sample name: BAM file name} lookups."""
MATE_POS = Dict[str, List[int]]
"""Dictionary of {ref/alt: [bp mate positions]} for a given sample."""
SEGMENT = Tuple[int, int, str, float]
"""Biased segment formatted as `(start, end, bias, p-value)`"""

MBP = 1_000_000
"""Mega base pair (1 million bp)."""

def parse_arguments() -> argparse.Namespace:
    """Parse command line arguments with argparse."""
    parser = argparse.ArgumentParser(description='Find allele-biased segments. '
                                     'Compare mates of reads with SNP alleles.')
    # File arguments
    parser.add_argument('-v', '--vcf', help='Path to the SNP VCF file')
    parser.add_argument('-d', '--bam-dir', help='Directory with BAM files')
    parser.add_argument('-o', '--output', help='Output CSV file path')
    parser.add_argument('-e', '--bam-ext',
                        required=False, default='.pos.sorted.bam',
                        help='Extension for BAMs (<sample>.ext)')
    
    # Sample/bias count arguments
    parser.add_argument('-O', '--max-opposite',
                        required=False, default=0, type=float,
                        help='Max share [0,0.5) of heterozygotes '
                             'with opposite bias')
    parser.add_argument('-N', '--max-neutral',
                        required=False, default=0, type=float,
                        help='Max share [0,1) of heterozygotes with 0 change')
    parser.add_argument('-D', '--max-drop', required=False, default=0, type=int,
                        help='Max number of dropped homozygous/missing samples')
    
    # Window arguments
    parser.add_argument('-w', '--window-width',
                        required=False, default=15, type=float,
                        help='Minimum window width, in Mbp, to scan with '
                             '(Consecutive windows are merged)')
    parser.add_argument('-s', '--move-step', 
                        required=False, default=None, type=float, 
                        help='Step to move window, in Mbp. Use one of -s or -r')
    parser.add_argument('-r', '--round-to',
                        required=False, default=None, type=float,
                        help='Mbp threshold to round read positions to for '
                             'empirical window choice. Use one of -s or -r')
    return parser.parse_args()

def check_illogical_arguments(args: argparse.Namespace) -> None:
    """Run initial argument validity checks."""
    if not os.path.isfile(args.vcf):
        raise FileNotFoundError(f'VCF {args.vcf} does not exist')
    if not os.path.isdir(args.bam_dir):
        raise FileNotFoundError(f'BAM dir {args.bam_dir} is not a directory')
    if '.bam' not in args.bam_ext:
        raise ValueError(f'BAM file extension must have ".bam"')
    
    if not (0 <= args.max_opposite < 0.5):
        raise ValueError(f'Max opposite samples share ({args.max_opposite}) '
                         'must be in [0, 0.5)')
    if not (0 <= args.max_opposite < 1):
        raise ValueError(f'Max neutral samples share ({args.max_neutral}) '
                         'must be in [0, 1)')
    
    if args.window_width <= 1:
        raise ValueError(f'Window width {args.window_width}Mbp must be >=1Mbp')
    if args.window_width >= 50:
        raise ValueError(f'Window width {args.window_width}Mbp is too large. '
                         'Did you enter a value in bp instead of Mbp?')
    if (args.move_step is not None) + (args.round_to is not None) != 1:
        raise ValueError(f'Use exactly one of -s or -r')
    if args.move_step:
        if args.move_step <= 0.5:
            raise ValueError(f'Window step {args.move_step}Mbp '
                             'must be >=0.5Mbp.')
        if args.move_step >= 10:
            raise ValueError(f'Window step {args.move_step}Mbp is too large. '
                             'Did you enter a vaue in bp instead of Mbp?')
    if args.round_to:
        if args.round_to <= 0.1:
            raise ValueError(f'Read rounding threshould {args.round_to}Mbp'
                             ' must be >=0.1Mbp.')
        if args.round_to >= 10:
            raise ValueError(f'Read rounding threshold {args.round_to}Mbp '
                             'is too large. Did you enter a value in bp '
                             'instead of Mbp?')
    
def locate_bams(dir: str, ext: str, min_samples: int) -> SAMPLE_BAMS:
    """Find BAM files within given directory.

    Assumes that files are named <sample_name>.<ext>
    
    Parameters
    ----------
    dir : str
        Directory to search within.
    ext : str
        File extension to search for.
    min_samples : int
        The minimum number of samples which should have BAM files.
    
    Returns
    -------
    SAMPLE_BAMS
        BAM files found.
    """

    bams = {file.split('.')[0]: f'{dir}/{file}'
            for file in os.listdir(dir) if file.endswith(ext)}
    if not bams:
        raise FileNotFoundError(f'No {dir}/*.{ext}')
    if min_samples > len(bams):
        raise ValueError(f'Arguments imply at least {min_samples} sample(s), '
                         f'but searching {dir}/*.{ext} found only {len(bams)}')
    return bams

def get_allele_mate_pos(bam_path: str, chrom: str, pos: int, 
                        ref: str, alt: str) -> MATE_POS:
    """Get mate positions for reads supporting ref/alt alleles.

    Ignores reads with unmapped mates and reads that do not cover the SNP.
    BAM file must be position-sorted and indexed for fast random access.

    Parameters
    ----------
    bam_path : str
        Path to the BAM file.
    chrom : str
        Chromosome of the SNP.
    pos : int
        Position of the SNP in bp.
    ref : str
        Reference allele of the SNP.
    alt : str
        Alternate allele of the SNP.

    Returns
    -------
    MATE_POS
        Two lists of bp positions: mates of ref/alt-supporting reads.
    """

    ref_mates = []
    alt_mates = []
    with pysam.AlignmentFile(bam_path, 'rb') as bam_file:
        for read in bam_file.fetch(chrom, pos - 1, pos):
            # We want mate pairs with high-quality mapping to the same chr
            if (read.is_secondary or read.mate_is_unmapped
                or read.reference_name != read.next_reference_name):
                continue
            
            ref_positions = read.get_reference_positions(full_length=True)
            # Handle deletions of the SNP position
            if pos - 1 not in ref_positions: continue
            
            base = read.query_sequence[ref_positions.index(pos - 1)]
            if base == ref:
                ref_mates.append(read.next_reference_start)
            elif base == alt:
                alt_mates.append(read.next_reference_start)
    
    return {'ref': sorted(ref_mates), 'alt': sorted(alt_mates)}

def count_biased_samples(all_mates: Dict[str, MATE_POS], 
                         all_ptrs: Dict[str, Dict[str, Dict[str, int]]],
                         cur_start: int, cur_end: int
                         ) -> Tuple[Dict[str, Dict[str, Dict[str, int]]], 
                                    Dict[str, int]]:
    """Count samples with read mate allele bias within a window.
    
    Assumes that all_mates is sorted, and that using
    all_ptrs to index into it would return reads <=
    the given endpoints, respectively.

    Parameters
    ----------
    all_mates : Dict[str, MATE_POS]
        `{sample_name: mate positions}` dictionary.
    all_ptrs : Dict[str, Dict[str, Dict[str, int]]]
        `{sample_name: {start/end: {ref/alt: index}}}` dictionary.
    cur_start : int
        Starting position of the window in bp, 0-indexed.
    cur_end : int
        Ending position of the window in bp, 0-indexed.

    Returns
    -------
    all_ptrs : Dict[str, Dict[str, Dict[str, int]]]
        Updated pointer dictionary.
    bias_counts : Dict[str, int]
        Number of samples with ref, alt, or neutral bias.
    """

    bias_counts = {'ref': 0, 'alt': 0, 'neutral': 0}
    for sample in all_mates.keys():
        mates = all_mates[sample]
        ptrs = all_ptrs[sample]

        # Adjust pointers to keep only mates within the current window
        for side, cutoff in {'start': cur_start, 'end': cur_end}.items():
            for allele in ['ref', 'alt']:
                i = ptrs[side][allele]
                while i < len(mates[allele]) and mates[allele][i] < cutoff:
                    i += 1
                ptrs[side][allele] = i

        ref_count = ptrs['end']['ref'] - ptrs['start']['ref']
        alt_count = ptrs['end']['alt'] - ptrs['start']['alt']

        if ref_count > alt_count: bias_counts['ref'] += 1
        elif alt_count > ref_count: bias_counts['alt'] += 1
        else: bias_counts['neutral'] += 1
    return all_ptrs, bias_counts

def adjust_biased_segments(biased_segments: List[Tuple[int, int, str]],
                           bias_counts: Dict[str, int], max_opposite_num: float,
                           max_neutral_num: float, cur_start: int, cur_end: int
                           ) -> List[Tuple[int, int, str]]:
    """Adjust/add the latest biased segment to the list.

    If this segment has bias, and is overlapping/consecutive with
    a previous segment, they are merged. Otherwise new biased
    segments are added to the end of the list.
    
    Parameters
    ----------
    biased_segments : List[Tuple[int, int, str]]
        Segments with bias so far, as `(start, end, bias)`.
    bias_counts : Dict[str, int] 
        Number of samples with ref, alt, or neutral bias.
    max_opposite_num : float
        Maximum # of samples with opposite bias.
    max_neutral_num : float
        Maximum # of samples with neutral bias.
    cur_start : int
        Starting position of the window in bp, 0-indexed.
    cur_end : int
        Ending position of the window in bp, 0-indexed.
    
    Returns
    -------
    List[Tuple[int, int, str]]
        Updated list of biased segments.
    """

    if (min(bias_counts['ref'], bias_counts['alt']) <= max_opposite_num
        and bias_counts['neutral'] <= max_neutral_num):
        bias = 'ref' if bias_counts['ref'] > bias_counts['alt'] else 'alt'
        # Extend previous segment if adjacent/overlapping and same bias
        if (biased_segments and biased_segments[-1][1] >= cur_start 
            and biased_segments[-1][2] == bias):
            biased_segments[-1] = (biased_segments[-1][0], cur_end, bias)
        else: biased_segments.append((cur_start, cur_end, bias))
    return biased_segments

def find_biased_segments(all_mates: Dict[str, MATE_POS], window_width: int,
                         window_starts: List[int], max_opposite: float,
                         max_neutral: float) -> List[Tuple[int, int, str]]:
    """Scan for read mate allele-biased segments.

    Scans the chromosome in 5Mbp steps to identify segments
    with consistent allele bias across samples.
    Excludes segments containing the SNP itself.

    Parameters
    ----------
    all_mates : Dict[str, MATE_POS]
        `{sample_name: mate positions}` dictionary.
    window_width : int
        Window width, in bp, to use during scanning.
    window_starts : List[int]
        Starting locations for windows to test.
    max_opposite : float
        Maximum % of samples with opposite bias.
    max_neutral : float
        Maximum % of samples without bias.

    Returns
    -------
    List[Tuple[int, int, str]]
        List of biased segments, each as `(start, end, bias)`.
    """

    max_opposite_num = max_opposite * len(all_mates)
    max_neutral_num = max_neutral * len(all_mates)

    biased_segments = []
    all_ptrs = {sample: {'start': {'ref': 0, 'alt': 0}, 
                         'end': {'ref': 0, 'alt': 0}}
                         for sample in all_mates.keys()}

    for cur_start in window_starts:
        cur_end = cur_start + window_width

        all_ptrs, bias_counts = count_biased_samples(all_mates, all_ptrs, 
                                                     cur_start, cur_end)
        biased_segments = adjust_biased_segments(
            biased_segments, bias_counts, max_opposite_num, 
            max_neutral_num, cur_start, cur_end)
    
    return [(start, end, bias) 
            for start, end, bias in biased_segments]

def add_binomial_pvalue(all_mates: Dict[str, MATE_POS],
                        biased_segments: List[Tuple[int, int, str]]
                        ) -> List[SEGMENT]:
    """
    Calculates binomial test p-values for allele-biased segments.

    Parameters
    ----------
    all_mates : Dict[str, MATE_POS]
        `{sample_name: mate positions}` dictionary.
    biased_segments : List[Tuple[int, int, str]]
        Output of `scan_for_biased_segments`, formatted as `(start, end, bias)`.

    Returns
    -------
    List[SEGMENT]
        List of biased segments, formatted as `(start, end, bias, p-value)`.
    """
    results = []

    # Initialize pointers for efficient counting
    all_ptrs = {sample: {'start': {'ref': 0, 'alt': 0}, 
                         'end': {'ref': 0, 'alt': 0}}
                         for sample in all_mates.keys()}

    for start, end, bias in biased_segments:
        ref_total, alt_total = 0, 0
        sample_counts = []

        for sample in all_mates.keys():
            mates = all_mates[sample]
            ptrs = all_ptrs[sample]

            # Adjust pointers to include only mates within the segment
            for side, cutoff in {"start": start, "end": end}.items():
                for allele in ["ref", "alt"]:
                    i = ptrs[side][allele]
                    while i < len(mates[allele]) and mates[allele][i] < cutoff:
                        i += 1
                    ptrs[side][allele] = i

            # Count ref/alt reads in the segment for this sample
            ref_count = ptrs["end"]["ref"] - ptrs["start"]["ref"]
            alt_count = ptrs["end"]["alt"] - ptrs["start"]["alt"]

            # Keep track of counts per sample for filtering
            if ref_count > alt_count:
                sample_counts.append(("ref", ref_count, alt_count))
                ref_total += 1
            elif alt_count > ref_count:
                sample_counts.append(("alt", ref_count, alt_count))
                alt_total += 1

        # Ignore neutral samples and test the observed bias using a binomial test
        if ref_total + alt_total > 0:
            # Number of samples in the majority bias group
            k = max(ref_total, alt_total)  
            n = ref_total + alt_total
            p_value = binomtest(k, n, p=0.5, alternative="two-sided").pvalue

            results.append((start, end, bias, p_value))

    return results

def run_pipeline(bams: SAMPLE_BAMS, max_opposite: float, max_neutral: float,
                 max_drop: int, record: pysam.VariantRecord, chr_length: int,
                 window_width: int, move_step: int = None,
                 round_to: int = None) -> List[SEGMENT]:
    """Run mate allele biased segment detection pipeline for a variant.
    
    Parameters
    ----------
    bams : SAMPLE_BAMS
        BAM files to use.
    max_opposite : float
        Maximum % of samples with opposite bias.
    max_neutral : float
        Maximum % of samples without bias.
    max_drop : int
        Maximum # of samples to drop.
    record : pysam.VariantRecord
        Variant to scan for.
    chr_length : int
        Length of this variant's chromosome.
    window_width : int
        Window width, in bp, to use during scanning.
    move_step : int [ default None ]
        Window step, in bp, to use during scanning.
        If None, then read rounding will be used.
    round_to : int [ default None ]
        What to round read positions to, in Mbp, for window start.
        If None, then window step will be used.

    Returns
    -------
    List[SEGMENT]
        Biased segments found.
    """

    # Skip SNPs which failed filtration or have >2 alleles
    if not record.filter or len(record.alts) > 2: return []

    chrom, snp_pos = record.chrom, record.pos
    ref, alt = record.ref, record.alts[0]

    # Only use heterozygous genotypes
    is_het = {name: s['GT'][0] != s['GT'][1]
              for name, s in record.samples.items()}
    if len(bams) - sum(is_het.values()) > max_drop: return []

    mates = {sample: get_allele_mate_pos(file, chrom, snp_pos, ref, alt)
                for sample, file in bams.items() if is_het[sample]}
    
    if move_step is not None:
        window_starts = range(0, chr_length - window_width + 1, move_step)
    else:
        window_starts = set()
        for sample_mates in mates.values():
            for allele_mates in sample_mates.values():
                for pos in allele_mates:
                    window_starts.add(round(pos / round_to) * round_to)
        window_starts = sorted(window_starts)

    window_starts = [pos for pos in window_starts if 
                    # Filter out windows which contain the SNP itself
                    not pos <= snp_pos <= pos + window_width]
    
    biased_segments = find_biased_segments(
        mates, window_width, window_starts, max_opposite, max_neutral)
    
    return add_binomial_pvalue(mates, biased_segments)

if __name__ == '__main__':
    args = parse_arguments()
    check_illogical_arguments(args)
    # At least one more than max_drop samples are needed for worst-case analysis
    bams = locate_bams(args.bam_dir, args.bam_ext, args.max_drop + 1)

    # Convert window arguments to bp whole numbers
    window_width = int(args.window_width * MBP)
    move_step = None if args.move_step is None else int(args.move_step * MBP)
    round_to = None if args.round_to is None else int(args.round_to * MBP)
    
    # Main logic
    with open(args.output, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        # Header row
        writer.writerow(['SNP_ID', 'CHROM', 'SNP_POS', 
                         'BIAS_START_MBP', 'BIAS_END_MBP', 'BIAS', 'P_VALUE'])

        with pysam.VariantFile(args.vcf) as vcf:
            for record in vcf:
                # Get results for this variant
                chr_length = vcf.header.contigs[record.chrom].length
                biased_segments = run_pipeline(
                    bams, args.max_opposite, args.max_neutral,
                    args.max_drop, record, chr_length, 
                    window_width, move_step, round_to)
                
                # Write results for this variant
                for start, end, bias, p in biased_segments:
                    writer.writerow([record.id, record.chrom, record.pos, 
                                    int(start / MBP), int(end / MBP), bias, p])